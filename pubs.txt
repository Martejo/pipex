void parent_process(int *pipe_fd, int i, int nbr_cmd, int *fd)
{
    if (i > 0)
        close(pipe_fd[READ]); // Fermer le fd de lecture du pipe précédent
    if (i < nbr_cmd - 1)
        close(pipe_fd[WRITE]); // Fermer le fd d'écriture du pipe actuel
    else
        close(fd[OUT]); // Fermer fd[OUT] dans le parent si c'est la dernière commande
}

int command_receiver(int nbr_cmd, char **cmds, char **env, int *fd)
{
    int i;
    int pipe_fd[2], prev_read_fd = fd[IN];
    int *pid;
    int status;

    pid = (int *)malloc(nbr_cmd * sizeof(int));
    if (!pid)
        ft_error(MALLOC_ERROR);

    for (i = 0; i < nbr_cmd; i++) 
    {
        if (i < nbr_cmd - 1) // Créer un pipe pour chaque commande sauf la dernière
        {
            if (pipe(pipe_fd) == -1)
                ft_error(PIPE_ERROR);
        }
        else
        {
            pipe_fd[WRITE] = fd[OUT];
        }

        pid[i] = fork_exec(cmds[i], (int[]){prev_read_fd, pipe_fd[WRITE]}, env, pid);

        parent_process(pipe_fd, i, nbr_cmd, fd);
        if (i < nbr_cmd - 1)
            prev_read_fd = pipe_fd[READ]; // Préparer l'entrée pour la prochaine commande
    }

    status = wait_pids(pid, nbr_cmd);
    return (status);
}

int fork_exec(char *cmd, int *fds, char **env, int *pid_tab)
{
    int pid = fork();
    if (pid == -1)
        ft_error("fork error");

    if (pid == 0)
    {
        if (fds[0] != STDIN_FILENO)
        {
            dup2(fds[0], STDIN_FILENO);
            close(fds[0]);
        }
        if (fds[1] != STDOUT_FILENO)
        {
            dup2(fds[1], STDOUT_FILENO);
            close(fds[1]);
        }
        exec(cmd, env, fds);
    }
    return pid;
}
